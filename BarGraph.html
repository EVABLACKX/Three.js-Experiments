<html>
<head>
    <title>Can your excel do this?</title>
    <script src="/bundles/Three/Three-min.js" type="text/javascript"></script>
    <script src="/bundles/Three/three.js/examples/js/Detector.js"></script>
    <script src="/bundles/Three/three.js/examples/js/Stats.js"></script>
    <script src="/bundles/Three/three.js/examples/js/Tween.js"></script>
    <style type="text/css">
        body {
            margin: 0px;
            padding: 0px;
            color: #fff;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            font-weight: bold;

            background-color: #000;
            overflow: hidden;
        }

        #container {
            position: absolute;
            left: 0px;
            top: 0px;
            width: 100%;
            height: 100%;
            margin: 0px;
            padding: 0px;
        }
    </style>
</head>

<body>
<script>
// <!--
if (!Detector.webgl) Detector.addGetWebGLMessage();
var clock = new THREE.Clock();
var SCREEN_HEIGHT = window.innerHeight;
var SCREEN_WIDTH = window.innerWidth;
var container, stats;
var camera, scene, renderer, mesh, light, ambientLight, dynamicHeight;
var grid = [];
var paused = false;
var last = new Date().getTime();
var down = false;
var moved = false;
var sx = 0, sy = 0;
var rot = Math.PI / 3;
var max = 0;

THREE.LeftAlign = 1;
THREE.CenterAlign = 0;
THREE.RightAlign = -1;
THREE.TopAlign = -1;
THREE.BottomAlign = 1;

init();
animate();

function init() {
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    document.body.appendChild(renderer.domElement);

    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '0px';
    document.body.appendChild(stats.domElement);

    renderer.setClearColorHex(0xEEEEEE, 1.0);
    renderer.shadowMapEnabled = true;
    renderer.shadowMapWidth = 1024;
    renderer.shadowMapHeight = 1024;
    renderer.shadowCameraFov = 35;

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(45, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 10000);
    camera.position.y = 150;
    camera.position.x = Math.cos(rot) * 170;
    camera.position.z = Math.sin(rot) * 170;
    scene.add(camera);

    light = new THREE.SpotLight();
    light.castShadow = true;
    light.position.set(-170, 300, 100);
    scene.add(light);

    ambientLight = new THREE.PointLight(0x442255);
    ambientLight.position.set(20, 150, -120);
    scene.add(ambientLight);

    var plane = new THREE.Mesh(
            new THREE.CubeGeometry(200, 20, 200),
            new THREE.MeshLambertMaterial({color: 0xFFFFFF}));
    plane.position.y = -10;
    plane.receiveShadow = true;
    plane.doubleSided = true;
    scene.add(plane);

    for (var y = 0; y < 10; y++) {
        grid[y] = [];
        for (var x = 0; x < 10; x++) {
            grid[y][x] = [];
            grid[y][x].height = (x * y) + 5;
            max = grid[y][x].height > max ? grid[y][x].height : max;
        }
    }

    var barGraph = new THREE.Object3D();
    scene.add(barGraph);

    //Marks 1-10 on the graph
    for (var j = 0; j < grid.length; j++) {
        var array = grid[j];
        var title = alignPlane(createText2D(j + 1), THREE.CenterAlign, THREE.CenterAlign);
        title.scale.set(0.25, 0.25, 0.25);
        title.position.x = (-1 - (array.length - 1) / 2) * 16;
        title.position.z = -(j - (grid.length - 1) / 2) * 16;
        title.position.y = 1;
        title.rotation.x = -Math.PI / 2;
        barGraph.add(title);
    }

    //Marks A-J on the graph
    for (var j = 0; j < grid[0].length; j++) {
        var array = grid[0];
        var c = String.fromCharCode(j + 65);
        var title = alignPlane(createText2D(c), THREE.CenterAlign, THREE.CenterAlign);
        title.scale.set(0.25, 0.25, 0.25);
        title.position.x = (j - (array.length - 1) / 2) * 16;
        title.position.z = -(-1 - (grid.length - 1) / 2) * 16;
        title.position.y = 1;
        title.rotation.x = -Math.PI / 2;
        barGraph.add(title);
    }

    //Init the bouncy!
    TWEEN.removeAll();
    dynamicHeight = {y: 1};
    //Draws the bars
    for (var j = 0; j < grid.length; j++) {
        var array = grid[j];
        for (var i = 0; i < array.length; i++) {
            var mat = new THREE.MeshPhongMaterial({color: 0xFFAA55});
            //var barHeight = array[i].height / max * 80;
            mat.color.setHSV(0.2 + 0.8 * array[i].height / max, 0.8, 1);
            var geo = new THREE.CubeGeometry(8, 2, 8);
            var mesh = new THREE.Mesh(geo, mat);
            mesh.position.x = (i - (array.length - 1) / 2) * 16;
            mesh.position.y = 2 / 2;
            mesh.position.z = -(j - (grid.length - 1) / 2) * 16;
            mesh.castShadow = mesh.receiveShadow = true;
            barGraph.add(mesh);
            grid[j][i].bar = mesh;

            var title = alignPlane(createText2D(array[i].height), THREE.CenterAlign, THREE.CenterAlign);
            title.scale.set(0.25, 0.25, 0.25);
            title.position.x = ((i - (array.length - 1) / 2) * 16) + 6;
            title.position.y = 2 + 1 / 2;
            title.position.z = -(j - (grid.length - 1) / 2) * 16;
            title.rotation.x = -Math.PI / 2;
            barGraph.add(title);
            grid[j][i].title = title;
        }
    }

    renderer.render(scene, camera);
    window.addEventListener('resize', onWindowResize, false);
}

function createTextCanvas(text, color, font, size) {
    size = size || 24;
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var fontStr = (size + 'px ') + (font || 'Arial');
    ctx.font = fontStr;
    var w = ctx.measureText(text).width;
    var h = Math.ceil(size * 1.25);
    canvas.width = w;
    canvas.height = h;
    ctx.font = fontStr;
    ctx.fillStyle = color || 'black';
    ctx.fillText(text, 0, size);
    return canvas;
}

function createText2D(text, color, font, size, segW, segH) {
    var canvas = createTextCanvas(text, color, font, size);
    var plane = new THREE.PlaneGeometry(canvas.width, canvas.height, segW, segH);
    var tex = new THREE.Texture(canvas);
    tex.needsUpdate = true;
    var planeMat = new THREE.MeshBasicMaterial({
        map: tex, color: 0xffffff, transparent: true
    });
    var mesh = new THREE.Mesh(plane, planeMat);
    mesh.doubleSided = true;
    return mesh;
}

function alignPlane(plane, horizontalAlign, verticalAlign) {
    var obj = new THREE.Object3D();
    var u = plane.geometry.vertices[0].position;
    var v = plane.geometry.vertices[plane.geometry.vertices.length - 1].position;
    var width = Math.abs(u.x - v.x);
    var height = Math.abs(u.y - v.y);
    plane.position.x = (width / 2) * horizontalAlign;
    plane.position.y = (height / 2) * verticalAlign;
    obj.add(plane);
    return obj;
}

document.onclick = function () {
    if (!moved) alert('You clicked');
}

window.onmousedown = function (ev) {
    down = true;
    moved = false;
    sx = ev.clientX;
    sy = ev.clientY;
};

window.onmouseup = function () {
    down = false;
};

window.onmousemove = function (ev) {
    moved = true;
    if (down) {
        var dx = ev.clientX - sx;
        var dy = ev.clientY - sy;
        rot += dx * 0.01;
        camera.position.x = Math.cos(rot) * 170;
        camera.position.z = Math.sin(rot) * 170;
        camera.position.y = Math.max(5, camera.position.y + dy);
        sx += dx;
        sy += dy;
    }
}

function animate() {
    render(clock.getDelta());
    stats.update();
    window.requestAnimationFrame(animate, renderer.domElement);
}

function render(t) {
    if (!paused) {
        last = t;
        renderer.clear();
        camera.lookAt(scene.position);
        renderer.render(scene, camera);
        dynamicHeight.y += .5;
        for (var j = 0; j < grid.length; j++) {
            var array = grid[j];
            for (var i = 0; i < array.length; i++) {
                var barHeight = array[i].height / max * 80;
                if (dynamicHeight.y < barHeight) {
                    grid[j][i]['bar'].scale.y = dynamicHeight.y / 2;
                    grid[j][i]['bar'].position.y = grid[j][i]['bar'].scale.y / 2;
                    grid[j][i]['title'].position.y = (dynamicHeight.y) + 1 /2.25;
                }
            }
        }
    }
}

function onWindowResize(event) {
    renderer.setSize(window.innerWidth, window.innerHeight);

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    camera.lookAt(scene.position);
}

onmessage = function (ev) {
    paused = (ev.data == 'pause');
};
// -->
</script>
</body>

</html>